/* autogenerated by Processing revision 1292 on 2023-07-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;
import java.util.*;
import java.io.*;
import java.nio.file.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Lyrical extends PApplet {

/*todo (in order of doing):
Add volume slider to upper right corner - make it live interactable
Change esc from quit to pause
If paused, make esc AND enter AND a clickable menu resume
Add an options menu as a second pop out window (like preferences in any application) that can display side by side the main window, which lets you alter preferences and view the alterations live
Options menu support for colour scheme changing
Options menu to enable/disable archiving lyrics
Add support for non txt/mp3 files (make grid of clickables in options menu where 
             any number can be selected/deselected so that any can be searched)
             
Button on song selection screen to reselect directory (for misinputs & altering old preferences)
Config file to remember preferences (including all options menu things, volume, & originally selected directory)

scroll functionality in the song selection ui if there are too many file available
arrow key support in song selection ui
  > make this a method for arrow key support in lyric saving/end of song UI

Make the loading screen trigger while waiting for the file to load!!! why is it broken!!!
  > current patch fix - window title displays the current status of the program
  
Make window resizeable/scale to different monitor resolutions

~do at any time~
General code cleanup oh my god its such a mess
Remove redundant variables/unnecessarily complicated code
Instead of duplicate button code, have a button interactions handler that lets me just create buttons fit to the text size (or that take inputs for x1/y1/width/height)
*/







//Use these when making colour selection UI, eventually integrate with a config file
int selectionColour = color(255, 40, 150);
int selectionColourSecondary = color(220, 20, 110);
int textColour = color(255);
int textColourSecondary = color(150);
int buttonColour = color(10);
int backgroundColour = color(30);

Controller ui;
Minim minim;
Archive archive;
List<File> ls;
ArrayList<MusicFile> files = new ArrayList<>();
AudioPlayer song;
SoundFile songDummy;
Boolean firstTime = true;
Boolean fileSelected = false;
Boolean folderSelected = false;
Boolean clicked = false;
Boolean failedToArchive = false;
int archiveFailedTimer = 0;
String[] lyrics, lryc, LyricSync;
File lyricsName, selectedDirectory;
String lyrName, fName;
int line = 0;
int activeFileIndex;
int xInit = 30;
int yInit = 150;
int offTime, currentMin, currentSec, currentMili;

public void setup(){
  PFont font;
  font = createFont("Dialog.plain", 5);
  textFont(font);
  minim = new Minim(this);
  archive = new Archive();
  ui = new Controller();
  /* size commented out by preprocessor */;
  selectFolder("Select directory of music:", "directSelect");
  //selectInput("Select lyric txt:", "fileSelected");
}

//ui
public void draw() {
  fill(backgroundColour);
  background(backgroundColour);
  stroke(backgroundColour);
  if(line == 0){
    offTime = millis();
  }
  ui.songInfo();
  if(lyrics != null){
    ui.lyricDisplay(lyrics, line, xInit, yInit);
    if(song != null && song.isPlaying()){
      timeFormat();
    }
    if(line == lyrics.length){
      EoSMenu();
    }
  }

  fill(buttonColour);
  rect(0, height-25, width, height);
  textSize(16);
  fill(textColourSecondary);
  String controlsExplain = "[ESC] to exit program at any time (without saving)           [ENTER] to advance to next lyric";
  text(controlsExplain, width/2 - textWidth(controlsExplain)/2, height-7);
  
  if(firstTime && !fileSelected){
    selector();
  }
  
  if(failedToArchive){
    //These colour values should not be variable methinks
    fill(100, 10, 10);
    rect(0, height-50, width, 26);
    textSize(16);
    fill(255);
    String errorExplain = "[.txt] file not added to archive! It will not be deleted from original directory";
    text(errorExplain, width/2 - textWidth(errorExplain)/2, height-32);
    if(millis()-archiveFailedTimer > 15000){
      failedToArchive = false;
      archiveFailedTimer = 0;
    }
  }
}

//input handling
public void keyPressed() {
  if(key==ENTER && !firstTime){
    if(line < lyrics.length){
      String a = (timeFormat() + lyrics[line]);
      println(a);
      lryc[line] = a;
      line++;
    }
  } else if (firstTime && key==ENTER){
    song.setVolume(.25f);
    song.play();
    String a = (timeFormat() + "");
    println(a);
    lryc[line] = a;
    firstTime = false;
    line++;
  }
  if(key==ESC){
    if(lyrics != null && line == lyrics.length){
      String fileName = fName+".lrc";
      saveStrings(fileName, LyricSync);
    }
    surface.setTitle("Quitting Safely...");
    exit();
  }
}

//formats the time tag
public String timeFormat(){
  int currentTime = millis()-offTime;
  currentMili = currentTime%1000;
  currentSec = (currentTime/1000);
  currentMin = currentSec/60;
  currentSec %= 60;
  String Sec = str(currentSec);
  String Min = str(currentMin);
  String Mili = str(currentMili);
  if(currentSec < 10){
    Sec = "0" + currentSec;
  }
  if(currentMin < 10){
    Min = "0" + currentMin;
  }
  if(currentMili < 10){
    Mili = "0" + currentMili;
  } else if (currentMili > 99){
    Mili = str(currentMili/10);
  }
  return ("[" + Min + ":" + Sec + "." + Mili + "] ");
}

//Select the directory
public void directSelect(File selection) {
  if (selection == null){
    println("Window closed or user hit cancel");
    exit();
  } else {
    println("Selected " + selection.getAbsolutePath());
    selectedDirectory = archive.makeDirectory(selection.getAbsolutePath());
  }
  addMusicFiles(selection);
  folderSelected = true;
}

public void addMusicFiles(File selection){
  ls = listf(selection);
  int x = xInit;
  int y = yInit;
  for(int i = 0; i < ls.size(); i++){
    files.add(new MusicFile(x, y, ls.get(i)));
    y+=38;
  }
}

public static FilenameFilter filter = new FilenameFilter(){
  public boolean accept(File f, String name){
    return name.endsWith(".txt");
  }
};

//Thanks to Cyrille Ka on stackoverflow in 2013
public static List<File> listf(File directoryName) {
  File directory = directoryName;
  
  List<File> resultList = new ArrayList<File>();

  // get all the files from a directory
  File[] fList = directory.listFiles(filter);
  resultList.addAll(Arrays.asList(fList));
  for (File file : fList) {
    if (file.isFile()) {
      //System.out.println(file.getAbsolutePath());
    } else if (file.isDirectory()) {
      resultList.addAll(listf(new File(file.getAbsolutePath())));
    }
  }
  return resultList;
}

//file selection code
public void fileSelected(File selection){
  fileSelected = true;
  if (selection == null){
    println("Invalid filetype/no file selected");
    exit();
  } else {
    println("Selected " + selection.getAbsolutePath());
  }
  String[] lyrrayPart = loadStrings(selection);
  lyrics = new String[lyrrayPart.length+1];
  lyrics[0] = " ";
  arraycopy(lyrrayPart, 0, lyrics, 1, lyrrayPart.length);
  
  lyricsName = selection;
  lryc = new String[lyrics.length+1];
  lyrName = lyricsName.toString();
  fName = lyrName.substring(0, (lyrName.length()-4));
  song = minim.loadFile(fName+".mp3");
  surface.setTitle("Loading...");
  songDummy = new SoundFile(this, fName+".mp3", false);
  println("Song loaded");
  surface.setTitle(selection.getName().substring(0, selection.getName().length()-4));
}

public void mouseClicked(){
  clicked = true;
}

public void selector(){
  int i = 0;
    int foundClick = 0;
    Boolean fc = false;
    for(i = 0; i < files.size(); i++){
      MusicFile mf = files.get(i);
      mf.fileDisplay();
      if(clicked){
        if(mf.UIfileSelected()){
          foundClick = i;
          fc = true;
        }
      }
    }
    clicked = false;
    if(fc){
      activeFileIndex = foundClick;
      fileSelected(ls.get(foundClick));
    }
}

//Handle end of song menu
public void EoSMenu(){
  fill(selectionColour);
  textSize(40);
  text("Lyrics Complete!", 20, 220); 
  int xTemp = xInit+40;
  int yTemp = yInit+95;
  String[] eos = {"Save & Select New", "Restart This Song", "Save & Choose New Directory", "Save & Quit", "Quit Without Saving"};
  int i = 0;
  int foundClick = 0;
  Boolean fc = false;
  for(i = 0; i < eos.length; i++){
    ui.menuDisplay(eos[i], xTemp, yTemp);
    if(clicked){
      if(ui.UIoptionSelected(eos[i], xTemp, yTemp)){
        foundClick = i;
        fc = true;
      }
    }
    yTemp += 45;
  }
  clicked = false;
  if(fc){
    songEnd(foundClick);
  }
}

//Handle end of song saving & such
public void songEnd(int a){
  int selection = a;
  LyricSync = Arrays.copyOf(lryc, lryc.length-1);
  ui.lyricDisplay(lyrics, line, xInit, yInit);
  String fileName = fName+".lrc";
  //save and select new + Choose new directory
  if(selection == 0 || selection == 2){
    println("Saved song, selecting new");
    saveStrings(fileName, LyricSync);
    archiveLyrics();
    song.pause();
    fill(textColour);
    resetVars();
    if(selection == 2){
      files = new ArrayList<>();
      selectFolder("Select directory of music:", "directSelect");
      print(", and selecting new directory");
    }
  }
  //Restart this song
  else if(selection == 1){
    println("Restarted song");
    fill(textColour);
    song.rewind();
    song.pause();
    firstTime = true;
    currentMin = 0;
    currentSec = 0;
    currentMili = 0;
    line = 0;
  } 
  //Save & quit
  else if(selection == 3){
    println("Saved & quit");
    saveStrings(fileName, LyricSync);
    archiveLyrics();
    surface.setTitle("Saving...");
    exit();
  }
  //Quit w/o saving
  else if(selection == 4){
    println("Exited without saving");
    surface.setTitle("Quitting Safely...");
    exit();
  }
}

public void archiveLyrics(){
  if(archive.fileTransfer(selectedDirectory, lyricsName.getAbsolutePath())){
    println("Removing txt file from original directory...");
    files.remove(activeFileIndex);
    ls.remove(activeFileIndex);
    lyricsName.delete();
  } else {
    failedToArchive = true;
    archiveFailedTimer = millis();
    println("File not added to archive - not deleting original");
  }
}

//Reset all variables to starting state (bar directory)
public void resetVars(){
  minim = new Minim(this);
  ui = new Controller();
  firstTime = true;
  clicked = false;
  line = 0;
  xInit = 30;
  yInit = 150;
  currentMin = 0;
  currentSec = 0; 
  currentMili = 0;
  lyrics = null;
  lryc = null; 
  LyricSync = null;
  fileSelected = false;
  song = null;
  songDummy.removeFromCache();
  songDummy = null;
  surface.setTitle("Lyrical");
}
public class Archive{
  String archiveName = "Lyrical_Archive";
  public Archive(){  
  }
  
  //Create archive directory if none exists - returns false if created, true if existing
  public File makeDirectory(String path){
    path+="\\" + archiveName;
    File archDir = new File(path);
    Path tempath = Paths.get(path);
    //if the directory already exists
    if(Files.exists(tempath)){
      println("Archive directory already exists!");
      return archDir;
    } else if(archDir.mkdir()) {
      println("Archive directory created");
      return archDir;
    }
    println("Archive doesn't exist, but failed to be created!");
    println("Exiting program...");
    exit();
    return archDir;
  }
  
  public Boolean fileTransfer(File f, String path){
    try{
      File pathFileTemp = new File(path);
      Path archDir = Paths.get(f.getAbsolutePath() + "\\" + pathFileTemp.getName());
      Path textFile = Paths.get(path);
      Files.copy(textFile, archDir, StandardCopyOption.REPLACE_EXISTING);
    
      if(Files.exists(archDir)){
        File orig = textFile.toFile();
        File copi = archDir.toFile();
        String[] original = loadStrings(orig);
        String[] copied = loadStrings(copi);
        if(copied.length == original.length){
          for(int i = 0; i < original.length; i++){
            if(!original[i].equals(copied[i])){
              println("Archival failed, archived file contents not equal to original!");
              return false;
            }
          }
        } else {
          println("Archival failed, archived file different length to original!");
          return false;
        }
      } else {
        println("Archival failed, original file not copied!");
      }  
      println("Successfully copied file!");
      return true;
    } catch (IOException io){
      println("Archival failed");
      return false;
    }
  }
}
public class MusicFile{
  int x, y, tempx;
  int currentMils = 0;
  File song;
  String name, tempName;
  int textScale = 20;
  public MusicFile(int xa, int ya, File music){
    x = xa;
    tempx = x;
    tempName = name;
    y = ya - 75;
    song = music;
    name = song.getName().substring(0, music.getName().length()-4);
  }
  
  public String name(){
    return name;
  }
  
  public void fileDisplay(){
    tempName = name;
    fill(buttonColour);
    if(UIfileSelected()){
      fill(selectionColour);
      if(textWidth(name) + tempx > .95f*width){
        if(currentMils == 0){
          currentMils = millis();
        }
        tempName += "   ||   ";
        tempx = x - PApplet.parseInt(((millis()-currentMils))%15000/15000.0f * textWidth(name));
        tempName += tempName;
      }
    } else {
      tempx = x;
      currentMils = 0;
    }
    textSize(textScale);
    rect(x-10, y+10, textWidth(name)+10, textScale+10, 0, 10, 10, 0);
    fill(textColour);
    text(name, tempx-5, y+textScale+11);
    fill(backgroundColour);
    rect(0, y+10, x-10, textScale+10);
  }
  
  public boolean UIfileSelected(){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+textScale+10){
      return true;
    }
    return false;
  }
}
public class Controller{
  int textScale = 25;
  AudioMetaData meta;
  public Controller(){
  }
  int xPos;
  public void songInfo(){
    fill(textColour);
    textSize(45);
    String seconds = "Loading...";
    //I have to do it this way because the way that minim handles time metadata is broken
    //and the default processing sound library uses to low a sample rate 
    //attempting to change it results in so many errors - it's a known bug
    if (song != null){
      if(songDummy != null){
        int time = PApplet.parseInt(songDummy.duration());
        if(time%60 > 9){
          seconds = str(time%60);
        } else if(time%60 != 0){
          seconds = "0" + time%60;
        } else {
          seconds = "00";
        }
        seconds = str(time/60) + ":" + seconds;
      }
      
      meta = song.getMetaData();
      String songname = meta.fileName();
      File sn = new File(songname);
      songname = sn.getName();
      songname = "Song: " + songname.substring(0, songname.length()-4);
      textSize(30);
      if(textWidth(songname) > .85f*width){
        songname += "   ||   ";
        xPos = PApplet.parseInt((1000-millis())%20000/20000.0f * textWidth(songname));
        songname += songname;
      } else {
        xPos = 15;
      }
      fill(selectionColour);
      text(songname, xPos, 64);
      textSize(15);
      fill(selectionColourSecondary);
      text("By " + meta.author(), 33, 83);
      textSize(20);

      text("Lines: " + (lyrics.length-1), 15, 35);
      textSize(30);
      text(currentMin + ":" + currentSec, 105, 35);
      textSize(20);
      text("   /" + seconds, 80+2*textWidth(currentMin + ":" + currentSec), 35);
      textSize(25);
      float pos = song.position();
      float len = songDummy.duration()*1000;
      float percent;
      if(pos < len){
        percent = pos*100.0f/len;
      } else {
        percent = 100;
      }
      fill(textColourSecondary);
      text(PApplet.parseInt(percent) + "%", 6*width/28, 115);
      int percentBar = PApplet.parseInt((percent/100.0f) * (3*width/7));
      fill(textColour);
      rect(width/28, 120, 12*width/28, 10, 8);
      fill(selectionColour);
      rect(width/28, 120, percentBar, 10, 8);
    } else if (lyrics == null){
      if(songDummy == null && fileSelected){
        loading();
        println("Loading song...");
      } else if(folderSelected){
        text("Please Select Song", 25, 60);
      } else{
        textSize(40);
        text("Please Select Song Folder", 25, 50);
        textSize(15);
        text("Ensure each song [.mp3] you wish to give lyrics has a matching .txt file \n which share a directory and filename with the song", 20, 90);
        fill(selectionColour);
        text("NOTE: If there is a .lrc for a song already in this directory, saving lyrics that song will overwrite it", 15, 150);
      }
    }
  }
  
  public void lyricDisplay(String[] lyr, int pos, int x, int y){
    textSize(20);
    //keep text in frame
    int a = 0;
    if(pos > 1){
      a = pos-1;
    }
    for(int i = a; i < lyr.length; i++){
      //highlight current lyric
      if(i == pos-1){
        fill(selectionColour);
        //visibility for instrumental sections
        if(!lyr[i].matches(".*[a-zA-Z]+.*")){
          text("/////////////", x+25, y);
        }
      }
      else{
        fill(textColour);
      }
      if(lyrics != null && line == lyrics.length){
        fill(selectionColour);
      }
      //show lyrics
      textSize(20);
      text(lyr[i], x+25, y);
      textSize(13);
      fill(textColourSecondary);
      if(i > 0){
        text(i + "/" + (lyr.length-1), x-20, y);
      }
      y+=23;
    }
  }
  
  public void loading(){
    textSize(40);
    String elli = "";
    for(int i = 0; i < second(); i++){
      elli += ".";
      if(elli.length() > 3){
        elli = "";
      }
    }
    fill(textColour);
    text("Loading Song" + elli, 25, 60);
    println("Loading Song" + elli);
  }
  
  public void menuDisplay(String name, int x, int y){
    fill(buttonColour);
    if(UIoptionSelected(name, x, y)){
      fill(selectionColour);
    }
    textSize(textScale);
    rect(x-10, y+10, textWidth(name)+10, textScale+10, 0, 10, 10, 0);
    fill(textColour);
    text(name, x-5, y+textScale+11);
    fill(backgroundColour);
    rect(0, y+10, x-10, textScale+10);
  }
  
  public boolean UIoptionSelected(String name, int x, int y){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+textScale+10){
      return true;
    }
    return false;
  }
}


  public void settings() { size(675, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Lyrical" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
