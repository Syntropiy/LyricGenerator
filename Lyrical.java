/* autogenerated by Processing revision 1292 on 2023-08-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;
import java.util.*;
import java.io.*;
import java.nio.file.*;
import java.lang.Math.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Lyrical extends PApplet {

/*todo (in order of doing):
Change esc from quit to pause
If paused, make esc AND enter AND a clickable menu resume
Add rewinding
Add support for non txt/mp3 files (make grid of clickables in options menu where 
             any number can be selected/deselected so that any can be searched)
Make option selections only alter the config file if a 'save' button is clicked in the options menu
             
Let user restart the song from any timestamp in the song

Let user edit the .txt lyric file by hand/open it up with a button press if they notice the lyrics are wrong
Let user edit the to-be-.lrc file by hand if they want to make by hand edits at the end of a song
   
Button on song selection screen or maybe options menu to reselect directory (for misinputs & altering old preferences)
Config file to remember preferences (including all options menu things, volume, & originally selected directory)
Upon exiting program, generate a log.txt of console so the user can review console events, probably store them wherever the config file will be stored

scroll functionality in the song selection ui if there are too many file available
arrow key support in song selection ui
  > make this a method for arrow key support in lyric saving/end of song UI

Make window resizeable/scale to different monitor resolutions

~do at any time~
General code cleanup oh my god its such a mess
Remove redundant variables/unnecessarily complicated code
Instead of duplicate button code, have a button interactions handler that lets me just create buttons fit to the text size (or that take inputs for x1/y1/width/height)

Known bugs:
  > When selecting songs, the draw() function freezes for a few seconds, longer the bigger the music file. 
    It's supposed to keep working and the songInfo function to handle the unloaded bits of song data on its own with 
    a little loading... animation, but instead the program appears to just freeze until the song is fully loaded.
  > When lyric-ing songs out of order, the menu displaying available songs will just not display a button where the last song was 
    so the list doesn't get shorter, it just gets holes in it
  > If a lyric is too long to display, it runs off screen
  > Non Latin text displays //// overlayed on top of it, which is not ideal when selected
  > Menu is inaccessable on the end of song menu
*/








//Use these when making colour selection UI, eventually integrate with a config file
int selectionColour = color(255, 40, 150);
int selectionColourSecondary = color(220, 20, 110);
int textColour = color(255);
int textColourSecondary = color(150);
int buttonColour = color(10);
int menuColour = color(0);
int backgroundColour = color(30);
int dummy = color(0);
int[] colVars = {dummy, selectionColour, selectionColourSecondary, textColour, textColourSecondary, buttonColour, menuColour, backgroundColour};
String[] colVarNames = {"dummy", "Selection", "Selection (2)", "Text", "Text (2)", "Buttons", "Menu", "Background"};

//Moves from 0 to 50 - my preference is @ 20/30
float volume = 20;

//Toggles whether or not files are archived
Boolean doArchive = true;

Controller ui;
Options options;
Minim minim;
Archive archive;
List<File> ls;
ArrayList<MusicFile> files = new ArrayList<>();
AudioPlayer song;
SoundFile songDummy;
Boolean firstTime = true;
Boolean fileSelected = false;
Boolean folderSelected = false;
Boolean clicked = false;
Boolean failedToArchive = false;
Boolean menuOpen = false;
int archiveFailedTimer = 0;
String[] lyrics, lryc, LyricSync;
File lyricsName, selectedDirectory;
String lyrName, fName;
int line = 0;
int activeFileIndex;
int xInit = 30;
int yInit = 150;
int offTime, currentMin, currentSec, currentMili;

public void setup(){
  PFont font;
  font = createFont("Dialog.plain", 5);
  textFont(font);
  minim = new Minim(this);
  options = new Options();
  archive = new Archive();
  ui = new Controller();
  /* size commented out by preprocessor */;
  selectFolder("Select directory of music:", "directSelect");
  //selectInput("Select lyric txt:", "fileSelected");
}

//ui
public void draw() {
  fill(colVars[7]);
  background(colVars[7]);
  stroke(colVars[7]);
  
  ui.songInfo();
  
  if(lyrics != null){
    ui.lyricDisplay(lyrics, line, xInit, yInit);
    if(song != null && song.isPlaying()){
      timeFormat();
      song.setGain(volume-44);
    }
    if(line == lyrics.length){
      EoSMenu();
    } else if(line == 0){
      offTime = millis();
    }
  } else if(firstTime && !fileSelected){
    selector();
  }
  
  options.button(clicked);
  
  fill(colVars[5]);
  rect(0, height-25, width, height);
  textSize(16);
  fill(colVars[4]);
  String controlsExplain = "[ESC] to exit program at any time (without saving)           [ENTER] to advance to next lyric";
  text(controlsExplain, width/2 - textWidth(controlsExplain)/2, height-7);
  
  if(failedToArchive){
    //These colour values should not be variable methinks
    fill(100, 10, 10);
    rect(0, height-50, width, 26);
    textSize(16);
    fill(255);
    String errorExplain = "[.txt] file not added to archive! It will not be deleted from original directory";
    text(errorExplain, width/2 - textWidth(errorExplain)/2, height-32);
    if(millis()-archiveFailedTimer > 15000){
      failedToArchive = false;
      archiveFailedTimer = 0;
    }
  }
  clicked = false;
}

//input handling
public void keyPressed() {
  if(key==ENTER && !firstTime){
    if(line < lyrics.length){
      String a = (timeFormat() + lyrics[line]);
      println(a);
      lryc[line] = a;
      line++;
    }
  } else if (firstTime && key==ENTER){
    song.play();
    String a = (timeFormat() + "");
    println(a);
    lryc[line] = a;
    firstTime = false;
    line++;
  }
  if(key==ESC){
    if(lyrics != null && line == lyrics.length){
      String fileName = fName+".lrc";
      saveStrings(fileName, LyricSync);
    }
    surface.setTitle("Quitting Safely...");
    exit();
  }
}

//formats the time tag
public String timeFormat(){
  int currentTime = millis()-offTime;
  currentMili = currentTime%1000;
  currentSec = (currentTime/1000);
  currentMin = currentSec/60;
  currentSec %= 60;
  String Sec = str(currentSec);
  String Min = str(currentMin);
  String Mili = str(currentMili);
  if(currentSec < 10){
    Sec = "0" + currentSec;
  }
  if(currentMin < 10){
    Min = "0" + currentMin;
  }
  if(currentMili < 10){
    Mili = "0" + currentMili;
  } else if (currentMili > 99){
    Mili = str(currentMili/10);
  }
  return ("[" + Min + ":" + Sec + "." + Mili + "] ");
}

//Select the directory
public void directSelect(File selection) {
  if (selection == null){
    println("Window closed or user hit cancel");
    exit();
  } else {
    println("Selected " + selection.getAbsolutePath());
    selectedDirectory = archive.makeDirectory(selection.getAbsolutePath());
  }
  addMusicFiles(selection);
  folderSelected = true;
}

public void addMusicFiles(File selection){
  ls = listf(selection);
  int x = xInit;
  int y = yInit;
  for(int i = 0; i < ls.size(); i++){
    files.add(new MusicFile(x, y, ls.get(i)));
    y+=38;
  }
}

public static FilenameFilter filter = new FilenameFilter(){
  public boolean accept(File f, String name){
    return name.endsWith(".txt");
  }
};

//Thanks to Cyrille Ka on stackoverflow in 2013
public static List<File> listf(File directoryName) {
  File directory = directoryName;
  
  List<File> resultList = new ArrayList<File>();

  // get all the files from a directory
  File[] fList = directory.listFiles(filter);
  resultList.addAll(Arrays.asList(fList));
  for (File file : fList) {
    if (file.isFile()) {
      //System.out.println(file.getAbsolutePath());
    } else if (file.isDirectory()) {
      resultList.addAll(listf(new File(file.getAbsolutePath())));
    }
  }
  return resultList;
}

//file selection code
public void fileSelected(File selection){
  fileSelected = true;
  if (selection == null){
    println("Invalid filetype/no file selected");
    exit();
  } else {
    println("Selected " + selection.getAbsolutePath());
  }
  String[] lyrrayPart = loadStrings(selection);
  lyrics = new String[lyrrayPart.length+1];
  lyrics[0] = " ";
  arraycopy(lyrrayPart, 0, lyrics, 1, lyrrayPart.length);
  
  lyricsName = selection;
  lryc = new String[lyrics.length+1];
  lyrName = lyricsName.toString();
  fName = lyrName.substring(0, (lyrName.length()-4));
  song = minim.loadFile(fName+".mp3");
  surface.setTitle("Loading...");
  songDummy = new SoundFile(this, fName+".mp3", false);
  println("Song loaded");
  surface.setTitle(selection.getName().substring(0, selection.getName().length()-4));
}

public void mouseClicked(){
  clicked = true;
}

public void selector(){
  int i = 0;
  int foundClick = 0;
  Boolean fc = false;
  for(i = 0; i < files.size(); i++){
    MusicFile mf = files.get(i);
    mf.fileDisplay();
    if(clicked && !menuOpen){
      if(mf.UIfileSelected()){
        foundClick = i;
        fc = true;
      }
    }
  }
  if(fc){
    activeFileIndex = foundClick;
    fileSelected(ls.get(foundClick));
  }
}

//Handle end of song menu
public void EoSMenu(){
  fill(colVars[1]);
  textSize(40);
  text("Lyrics Complete!", 20, 220); 
  int xTemp = xInit+40;
  int yTemp = yInit+95;
  String[] eos = {"Save & Select New", "Restart This Song", "Save & Choose New Directory", "Save & Quit", "Quit Without Saving"};
  int i = 0;
  int foundClick = 0;
  Boolean fc = false;
  for(i = 0; i < eos.length; i++){
    ui.menuDisplay(eos[i], xTemp, yTemp);
    if(clicked){
      if(ui.UIoptionSelected(eos[i], xTemp, yTemp)){
        foundClick = i;
        fc = true;
      }
    }
    yTemp += 45;
  }
  clicked = false;
  if(fc){
    songEnd(foundClick);
  }
}

//Handle end of song saving & such
public void songEnd(int a){
  int selection = a;
  LyricSync = Arrays.copyOf(lryc, lryc.length-1);
  ui.lyricDisplay(lyrics, line, xInit, yInit);
  String fileName = fName+".lrc";
  //save and select new + Choose new directory
  if(selection == 0 || selection == 2){
    println("Saved song, selecting new");
    saveStrings(fileName, LyricSync);
    archiveLyrics();
    song.pause();
    fill(colVars[3]);
    resetVars();
    if(selection == 2){
      files = new ArrayList<>();
      selectFolder("Select directory of music:", "directSelect");
      print(", and selecting new directory");
    }
  }
  //Restart this song
  else if(selection == 1){
    println("Restarted song");
    fill(colVars[3]);
    song.rewind();
    song.pause();
    firstTime = true;
    currentMin = 0;
    currentSec = 0;
    currentMili = 0;
    line = 0;
  } 
  //Save & quit
  else if(selection == 3){
    println("Saved & quit");
    saveStrings(fileName, LyricSync);
    archiveLyrics();
    surface.setTitle("Saving...");
    exit();
  }
  //Quit w/o saving
  else if(selection == 4){
    println("Exited without saving");
    surface.setTitle("Quitting Safely...");
    exit();
  }
}

public void archiveLyrics(){
  if(archive.fileTransfer(selectedDirectory, lyricsName.getAbsolutePath()) && doArchive){
    println("Removing txt file from original directory...");
    files.remove(activeFileIndex);
    ls.remove(activeFileIndex);
    lyricsName.delete();
  } else if(doArchive){
    failedToArchive = true;
    archiveFailedTimer = millis();
    println("File not added to archive - not deleting original");
  } else {
    println("doArchive (" + doArchive + ") should be false");
  }
}

//Reset all variables to starting state (bar directory)
public void resetVars(){
  minim = new Minim(this);
  ui = new Controller();
  firstTime = true;
  clicked = false;
  line = 0;
  xInit = 30;
  yInit = 150;
  currentMin = 0;
  currentSec = 0; 
  currentMili = 0;
  lyrics = null;
  lryc = null; 
  LyricSync = null;
  fileSelected = false;
  song = null;
  songDummy.removeFromCache();
  songDummy = null;
  surface.setTitle("Lyrical");
}
public class Archive{
  String archiveName = "Lyrical_Archive";
  public Archive(){  
  }
  
  //Create archive directory if none exists - returns false if created, true if existing
  public File makeDirectory(String path){
    path+="\\" + archiveName;
    File archDir = new File(path);
    Path tempath = Paths.get(path);
    //if the directory already exists
    if(Files.exists(tempath)){
      println("Archive directory already exists!");
      return archDir;
    } else if(archDir.mkdir()) {
      println("Archive directory created");
      return archDir;
    }
    println("Archive doesn't exist, but failed to be created!");
    println("Exiting program...");
    exit();
    return archDir;
  }
  
  public Boolean fileTransfer(File f, String path){
    try{
      File pathFileTemp = new File(path);
      Path archDir = Paths.get(f.getAbsolutePath() + "\\" + pathFileTemp.getName());
      Path textFile = Paths.get(path);
      Files.copy(textFile, archDir, StandardCopyOption.REPLACE_EXISTING);
    
      if(Files.exists(archDir)){
        File orig = textFile.toFile();
        File copi = archDir.toFile();
        String[] original = loadStrings(orig);
        String[] copied = loadStrings(copi);
        if(copied.length == original.length){
          for(int i = 0; i < original.length; i++){
            if(!original[i].equals(copied[i])){
              println("Archival failed, archived file contents not equal to original!");
              return false;
            }
          }
        } else {
          println("Archival failed, archived file different length to original!");
          return false;
        }
      } else {
        println("Archival failed, original file not copied!");
      }  
      println("Successfully copied file!");
      return true;
    } catch (IOException io){
      println("Archival failed");
      return false;
    }
  }
}
public class MusicFile{
  int x, y, tempx;
  int currentMils = 0;
  File song;
  String name, tempName;
  int textScale = 20;
  public MusicFile(int xa, int ya, File music){
    x = xa;
    tempx = x;
    tempName = name;
    y = ya - 75;
    song = music;
    name = song.getName().substring(0, music.getName().length()-4);
  }
  
  public String name(){
    return name;
  }
  
  public void fileDisplay(){
    tempName = name;
    fill(colVars[5]);
    stroke(colVars[2]);
    if(UIfileSelected() && !menuOpen){
      fill(colVars[1]);
      stroke(colVars[3]);
      if(textWidth(name) + tempx > .95f*width){
        if(currentMils == 0){
          currentMils = millis();
        }
        tempName += "   ||   ";
        tempx = x - PApplet.parseInt(((millis()-currentMils))%15000/15000.0f * textWidth(name));
        tempName += tempName;
      }
    } else {
      tempx = x;
      currentMils = 0;
    }
    textSize(textScale);
    rect(x-10, y+10, textWidth(name)+10, textScale+10, 0, 10, 10, 0);
    fill(colVars[3]);
    text(name, tempx-5, y+textScale+11);
    fill(colVars[7]);
    stroke(colVars[7]);
    rect(0, y+10, x-11, textScale+10);
  }
  
  public boolean UIfileSelected(){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+textScale+10){
      return true;
    }
    return false;
  }
}
public class Options{
  int red;
  int green;
  int blue;
  int buttonScale = 20;
  int buttonOffsetX = PApplet.parseInt(width/20 + 30);
  int pressing;
  Boolean boo = false;
  int openTime = 0;
  int setHeight = height/3;
  float menuHeight = height/3;
  int yShift;
  int xShift;
  String openMenu;
  String optionsMenuHead = "options";
  int colourToChange = 0;
  
  public Options(){ 
    red = PApplet.parseInt(red(colVars[0]));
    green = PApplet.parseInt(green(colVars[0]));
    blue = PApplet.parseInt(blue(colVars[0]));
  }
  
  public void button(Boolean mouseReleased){
    textSize(buttonScale);
    fill(colVars[3]);
    if(boo){
      menuOpen = true;
      stroke(colVars[1]);
      fill(colVars[6], 220);
      menuHeight = height - (millis()-openTime)*4;
      if(menuHeight <= setHeight){
        menuHeight = setHeight;
      }
      rect(width/20, menuHeight, width-2*width/20, height*2/3, 20, 20, 20, 20);
      
      doArchive = menuButtons("Archive .txt files on .lrc generation", buttonOffsetX, PApplet.parseInt(menuHeight+50), mouseReleased, doArchive, buttonScale);
      int colSel = colourVariables(buttonOffsetX+300, PApplet.parseInt(menuHeight+100), mouseReleased);
      red = menuSlider(buttonOffsetX, PApplet.parseInt(menuHeight+120), red, "Red", 0);
      green = menuSlider(buttonOffsetX, PApplet.parseInt(menuHeight+150), green, "Green", 1);
      blue = menuSlider(buttonOffsetX, PApplet.parseInt(menuHeight+180), blue, "Blue", 2);
      colVars[colSel] = color(red, green, blue);
      
      textSize(buttonScale+15);
      fill(255);
      float centerTitleHeight = menuHeight + 40;
      float centerTitle = (width-2*width/20)/2 + width/20 - textWidth(optionsMenuHead)/2;
      //Thanks to TFGuy44 on processing forums for this little code snippet!
      for(int x = -1; x < 2; x++){
        for(int y = -1; y < 2; y++){
          text(optionsMenuHead, centerTitle+x, centerTitleHeight+y);
        }
        text(optionsMenuHead, centerTitle+x, centerTitleHeight);
        text(optionsMenuHead, centerTitle, centerTitleHeight+x);
      }
      
      fill(red, green, blue);
      rect(buttonOffsetX-20, PApplet.parseInt(menuHeight+120), 7, 68, 4, 4, 4, 4);
      text(optionsMenuHead, centerTitle, centerTitleHeight);
      
      textSize(buttonScale);
      
      fill(colVars[2]);
      stroke(colVars[3]);
      openMenu = "v";
      yShift = 4;
      xShift = PApplet.parseInt(width-textWidth(openMenu)-11);
    } else {
      menuOpen = false;
      fill(colVars[5]);
      stroke(colVars[2]);
      openMenu = "^";
      yShift = 0;
      xShift = PApplet.parseInt(width-textWidth(openMenu)-5);
    }
    //println(int(width-textWidth(">")-5));
    textSize(buttonScale);
    menuDisplay(openMenu, xShift, height-buttonScale-45, yShift, mouseReleased);
  }
  
  //Create colour var selection buttons
  public int colourVariables(int x, int y, Boolean mouseReleased){
    //{selectionColour, selectionColourSecondary, textColour, textColourSecondary, buttonColour, menuColour, backgroundColour}
    for(int i = 0; i < colVars.length; i++){
      Boolean isCurrentlySelected = i == colourToChange;
      if(i != 0 && i < 4 && menuButtons(colVarNames[i], x, y + 28*(i-1), mouseReleased, isCurrentlySelected, 15)){
        colourToChange = i;
      } else if (i > 3 && i < 7 && menuButtons(colVarNames[i], PApplet.parseInt(x+textWidth(colVarNames[i-3])+20), y + 28*(i-4), mouseReleased, isCurrentlySelected, 15)) {
        colourToChange = i;
      } else if (i > 6 && menuButtons(colVarNames[i], PApplet.parseInt(x+104), y + 28*(2), mouseReleased, isCurrentlySelected, 15)){
        colourToChange = i;
      }
    }
    red = PApplet.parseInt(red(colVars[colourToChange]));
    green = PApplet.parseInt(green(colVars[colourToChange]));
    blue = PApplet.parseInt(blue(colVars[colourToChange]));
    return colourToChange;
  }
  
  //display the options menu button & handle if it's active or not
  public void menuDisplay(String name, int x, int y, int yShift, Boolean mouseReleased){
    if(optionSelected(name, x, y)){
      fill(colVars[1]);
      if(mouseReleased){
        boo = !boo;
        openTime = millis();
      }
    }
    textSize(buttonScale);
    rect(x-10, y+10, textWidth(name)+13, textWidth(name)+13, 10, 10, 10, 10);
    fill(colVars[3]);
    text(name, x-3, y+buttonScale+12-yShift);
    stroke(colVars[7]);
  }
  
  //Handle the options in the menu
  public Boolean menuButtons(String name, int x, int y, Boolean mouseReleased, Boolean valueChange, int butScale){
    fill(colVars[5]);
    stroke(colVars[2]);
    Boolean testSelected = optionSelected(name, x, y);
    if(testSelected || valueChange){
      fill(colVars[1]);
      if(mouseReleased && testSelected){
        return !valueChange;
      }
    }
    if(valueChange){
      stroke(colVars[3]);
    }
    textSize(butScale);
    rect(x-10, y+10, textWidth(name)+13, butScale+8, 10, 10, 10, 10);
    fill(colVars[3]);
    text(name, x-3, y+butScale+12);
    stroke(colVars[7]);
    fill(colVars[5]);
    return valueChange;
  }
  
  public int menuSlider(int x, int y, int shade, String colourName, int rgb){
    int selectedShade;
    int absoluteShade;
    if(rgb == 0){
      selectedShade = color(shade, 0, 0);
      absoluteShade = color(255, 40, 80);
    } else if(rgb == 1){
      selectedShade = color(0, shade, 0);
      absoluteShade = color(40, 255, 80);
    } else {
      selectedShade = color(0, 0, shade);
      absoluteShade = color(60, 110, 255);
    }
    
    fill(colVars[4]);
    int sliderX = x;
    float colWidth = shade;
    Boolean onThisSlider = (mouseX >= sliderX && mouseX <= sliderX + 256) && (mouseY < y+7 && mouseY > y-7 && mousePressed);
    if((pressing < 0 && onThisSlider) || (pressing == rgb && mousePressed)){
      pressing = rgb;
      colWidth = mouseX - sliderX;
      if(colWidth > 255){
        colWidth = 255;
      } else if (colWidth < 0) {
        colWidth = 0;
      }
      shade = PApplet.parseInt(colWidth);
      textSize(13);
      String percentVolume = str(shade) + "/255";
      float perVolX = sliderX + colWidth-textWidth(percentVolume)-5;
      if(perVolX <= sliderX+5){
        perVolX = sliderX+5;
      }
      text(percentVolume, perVolX, y-6);
    } else {
      if(pressing == rgb){
        pressing = -1;
      }
      textSize(14);
      fill(absoluteShade);
      text(colourName, sliderX + 256/2 - textWidth(colourName)/2 , y-5);
    }
    //draw slider
    fill(colVars[4]);
    rect(sliderX, y, 256, 7, 4, 4, 4, 4);
    //Colour aesthetics
    stroke(255);
    fill(selectedShade);
    rect(sliderX, y, colWidth, 6, 4, 4, 4, 4);
    fill(selectedShade);
    circle(sliderX + colWidth, y+3, 12);
    noStroke();
    rect(sliderX+1, y+1, colWidth-1, 5, 4, 4, 4, 4);
    stroke(colVars[7]);
    return shade;
  }
  
  //returns if mouse is hovering over an element
  public boolean optionSelected(String name, int x, int y){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+buttonScale+10){
      return true;
    }
    return false;
  }
}
public class Controller{
  int textScale = 25;
  Boolean pressing = false;
  AudioMetaData meta;
  public Controller(){
  }
  int xPos;
  public void songInfo(){
    fill(colVars[3]);
    textSize(45);
    String seconds = "Loading...";
    //I have to do it this way because the way that minim handles time metadata is broken
    //and the default processing sound library uses to low a sample rate 
    //attempting to change it results in so many errors - it's a known bug
    if (song != null){
      if(songDummy != null){
        int time = PApplet.parseInt(songDummy.duration());
        if(time%60 > 9){
          seconds = str(time%60);
        } else if(time%60 != 0){
          seconds = "0" + time%60;
        } else {
          seconds = "00";
        }
        seconds = str(time/60) + ":" + seconds;
      }
      
      meta = song.getMetaData();
      String songname = meta.fileName();
      File sn = new File(songname);
      songname = sn.getName();
      songname = "Song: " + songname.substring(0, songname.length()-4);
      textSize(30);
      if(textWidth(songname) > .85f*width){
        songname += "   ||   ";
        xPos = PApplet.parseInt((1000-millis())%20000/20000.0f * textWidth(songname));
        songname += songname;
      } else {
        xPos = 15;
      }
      fill(colVars[1]);
      text(songname, xPos, 64);
      textSize(15);
      fill(colVars[2]);
      text("By " + meta.author(), 33, 83);
      textSize(20);

      text("Lines: " + (lyrics.length-1), 15, 35);
      textSize(30);
      text(currentMin + ":" + currentSec, 105, 35);
      textSize(20);
      text("   /" + seconds, 80+2*textWidth(currentMin + ":" + currentSec), 35);
      textSize(25);
      float pos = song.position();
      float len = songDummy.duration()*1000;
      float percent;
      if(pos < len){
        percent = pos*100.0f/len;
      } else {
        percent = 100;
      }
      fill(colVars[4]);
      text(PApplet.parseInt(percent) + "%", 6*width/28, 115);
      int percentBar = PApplet.parseInt((percent/100.0f) * (3*width/7));
      fill(colVars[3]);
      rect(width/28, 120, 12*width/28, 10, 8);
      fill(colVars[1]);
      rect(width/28, 120, percentBar, 10, 8);
    } else if (lyrics == null){
      if(songDummy == null && fileSelected){
        loading();
        println("Loading song...");
      } else if(folderSelected){
        text("Please Select Song", 25, 60);
      } else{
        textSize(40);
        text("Please Select Song Folder", 25, 50);
        textSize(15);
        text("Ensure each song [.mp3] you wish to give lyrics has a matching .txt file \n which share a directory and filename with the song", 20, 90);
        fill(colVars[1]);
        text("NOTE: If there is a .lrc for a song already in this directory, saving lyrics that song will overwrite it", 15, 150);
      }
    }
    volumeSlider();
  }
  
  public void lyricDisplay(String[] lyr, int pos, int x, int y){
    textSize(20);
    //keep text in frame
    int a = 0;
    if(pos > 1){
      a = pos-1;
    }
    for(int i = a; i < lyr.length; i++){
      //highlight current lyric
      if(i == pos-1){
        fill(colVars[1]);
        //visibility for instrumental sections
        if(!lyr[i].matches(".*[a-zA-Z]+.*")){
          text("/////////////", x+25, y);
        }
      }
      else{
        fill(colVars[3]);
      }
      if(lyrics != null && line == lyrics.length){
        fill(colVars[1]);
      }
      //show lyrics
      textSize(20);
      text(lyr[i], x+25, y);
      textSize(13);
      fill(colVars[4]);
      if(i > 0){
        text(i + "/" + (lyr.length-1), x-20, y);
      }
      y+=23;
    }
  }
  
  public void loading(){
    textSize(40);
    String elli = "";
    for(int i = 0; i < second(); i++){
      elli += ".";
      if(elli.length() > 3){
        elli = "";
      }
    }
    fill(colVars[3]);
    text("Loading Song" + elli, 25, 60);
    println("Loading Song" + elli);
  }
  
  public void menuDisplay(String name, int x, int y){
    fill(colVars[5]);
    stroke(colVars[1]);
    textSize(textScale);
    if(UIoptionSelected(name, x, y)){
      fill(colVars[1]);
      stroke(colVars[3]);
    }
    rect(x-10, y+10, textWidth(name)+10, textScale+10, 0, 10, 10, 0);
    fill(colVars[3]);
    text(name, x-5, y+textScale+11);
    fill(colVars[7]);
    stroke(colVars[7]);
    rect(0, y+10, x-11, textScale+10);
  }
  
  public boolean UIoptionSelected(String name, int x, int y){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+textScale+10){
      return true;
    }
    return false;
  }
  
  public void volumeSlider(){
    fill(colVars[4]);
    int sliderX = PApplet.parseInt(width*5.15f/7);
    float volumeWidth = volume/50.0f * PApplet.parseInt(width/4);
    if((mouseX >= sliderX && mouseX <= sliderX+PApplet.parseInt(width/4)) && ((mouseY < 20 && mouseY > 5 && mousePressed) || (pressing && mousePressed))){
      pressing = true;
      volumeWidth = mouseX - sliderX;
      volume = volumeWidth/1.68f/2;
      textSize(13);
      String percentVolume = str(PApplet.parseInt(volume*20)/10.0f) + "%";
      float perVolX = sliderX + volumeWidth-textWidth(percentVolume)-5;
      float perVolY = 34;
      if(perVolX <= sliderX+5){
        perVolY += sliderX+5 - perVolX;
        if(perVolY >= 40){
          perVolY = 40;
        }
        perVolX = sliderX+5;
      }
      text(percentVolume, perVolX, perVolY);
    } else {
      pressing = false;
      textSize(14);
      fill(colVars[2]);
      String vol = "volume".substring(0, PApplet.parseInt(6 * volume/50.0f + 0.5f));
      String ume = "volume".substring(PApplet.parseInt(6 * volume/50.0f + 0.5f));
      float pos = sliderX + PApplet.parseInt(width/4)/2 + textWidth("volume")/2;
      text(vol, pos - textWidth("volume"), 30);
      fill(colVars[4]);
      text(ume, pos - textWidth(ume), 30);
    }
    //Volume bar
    fill(colVars[4]);
    rect(sliderX, 10, PApplet.parseInt(width/4), 7, 4, 4, 4, 4);
    //Volume indicator
    fill(colVars[2]);
    circle(sliderX + volumeWidth, 13, 12);
    //Colour aesthetics
    stroke(colVars[2]);
    rect(sliderX, 10, volumeWidth, 6, 4, 4, 4, 4);
    stroke(colVars[7]);
  }
}


  public void settings() { size(675, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Lyrical" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
