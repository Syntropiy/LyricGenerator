/* autogenerated by Processing revision 1292 on 2023-08-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;
import java.util.*;
import java.io.*;
import java.nio.file.*;
import java.lang.Math.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Lyrical extends PApplet {

/*todo (in order of doing):
Change esc from quit to pause
If paused, make esc AND enter AND a clickable menu resume
Add rewinding
Options menu support for colour scheme changing
Add support for non txt/mp3 files (make grid of clickables in options menu where 
             any number can be selected/deselected so that any can be searched)
             
Button on song selection screen or maybe options menu to reselect directory (for misinputs & altering old preferences)
Config file to remember preferences (including all options menu things, volume, & originally selected directory)

scroll functionality in the song selection ui if there are too many file available
arrow key support in song selection ui
  > make this a method for arrow key support in lyric saving/end of song UI

Make window resizeable/scale to different monitor resolutions

~do at any time~
General code cleanup oh my god its such a mess
Remove redundant variables/unnecessarily complicated code
Instead of duplicate button code, have a button interactions handler that lets me just create buttons fit to the text size (or that take inputs for x1/y1/width/height)

Known bugs:
  > When selecting songs, the draw() function freezes for a few seconds, longer the bigger the music file. 
    It's supposed to keep working and the songInfo function to handle the unloaded bits of song data on its own with 
    a little loading... animation, but instead the program appears to just freeze until the song is fully loaded.
  > When lyric-ing songs out of order, the menu displaying available songs will just not display a button where the last song was 
    so the list doesn't get shorter, it just gets holes in it
  > If a lyric is too long to display, it runs off screen
*/








//Use these when making colour selection UI, eventually integrate with a config file
int selectionColour = color(255, 40, 150);
int selectionColourSecondary = color(220, 20, 110);
int textColour = color(255);
int textColourSecondary = color(150);
int buttonColour = color(10);
int menuColour = color(0);
int backgroundColour = color(30);

//Moves from 0 to 50 - my preference is @ 20/30
float volume = 20;

//Toggles whether or not files are archived
Boolean doArchive = true;

Controller ui;
Options options;
Minim minim;
Archive archive;
List<File> ls;
ArrayList<MusicFile> files = new ArrayList<>();
AudioPlayer song;
SoundFile songDummy;
Boolean firstTime = true;
Boolean fileSelected = false;
Boolean folderSelected = false;
Boolean clicked = false;
Boolean failedToArchive = false;
Boolean menuOpen = false;
int archiveFailedTimer = 0;
String[] lyrics, lryc, LyricSync;
File lyricsName, selectedDirectory;
String lyrName, fName;
int line = 0;
int activeFileIndex;
int xInit = 30;
int yInit = 150;
int offTime, currentMin, currentSec, currentMili;

public void setup(){
  PFont font;
  font = createFont("Dialog.plain", 5);
  textFont(font);
  minim = new Minim(this);
  options = new Options();
  archive = new Archive();
  ui = new Controller();
  /* size commented out by preprocessor */;
  selectFolder("Select directory of music:", "directSelect");
  //selectInput("Select lyric txt:", "fileSelected");
}

//ui
public void draw() {
  fill(backgroundColour);
  background(backgroundColour);
  stroke(backgroundColour);
  
  ui.songInfo();
  
  if(lyrics != null){
    ui.lyricDisplay(lyrics, line, xInit, yInit);
    if(song != null && song.isPlaying()){
      timeFormat();
      song.setGain(volume-44);
    }
    if(line == lyrics.length){
      EoSMenu();
    } else if(line == 0){
      offTime = millis();
    }
  } else if(firstTime && !fileSelected){
    selector();
  }
  
  options.button(clicked);
  
  fill(buttonColour);
  rect(0, height-25, width, height);
  textSize(16);
  fill(textColourSecondary);
  String controlsExplain = "[ESC] to exit program at any time (without saving)           [ENTER] to advance to next lyric";
  text(controlsExplain, width/2 - textWidth(controlsExplain)/2, height-7);
  
  if(failedToArchive){
    //These colour values should not be variable methinks
    fill(100, 10, 10);
    rect(0, height-50, width, 26);
    textSize(16);
    fill(255);
    String errorExplain = "[.txt] file not added to archive! It will not be deleted from original directory";
    text(errorExplain, width/2 - textWidth(errorExplain)/2, height-32);
    if(millis()-archiveFailedTimer > 15000){
      failedToArchive = false;
      archiveFailedTimer = 0;
    }
  }
  clicked = false;
}

//input handling
public void keyPressed() {
  if(key==ENTER && !firstTime){
    if(line < lyrics.length){
      String a = (timeFormat() + lyrics[line]);
      println(a);
      lryc[line] = a;
      line++;
    }
  } else if (firstTime && key==ENTER){
    song.play();
    String a = (timeFormat() + "");
    println(a);
    lryc[line] = a;
    firstTime = false;
    line++;
  }
  if(key==ESC){
    if(lyrics != null && line == lyrics.length){
      String fileName = fName+".lrc";
      saveStrings(fileName, LyricSync);
    }
    surface.setTitle("Quitting Safely...");
    exit();
  }
}

//formats the time tag
public String timeFormat(){
  int currentTime = millis()-offTime;
  currentMili = currentTime%1000;
  currentSec = (currentTime/1000);
  currentMin = currentSec/60;
  currentSec %= 60;
  String Sec = str(currentSec);
  String Min = str(currentMin);
  String Mili = str(currentMili);
  if(currentSec < 10){
    Sec = "0" + currentSec;
  }
  if(currentMin < 10){
    Min = "0" + currentMin;
  }
  if(currentMili < 10){
    Mili = "0" + currentMili;
  } else if (currentMili > 99){
    Mili = str(currentMili/10);
  }
  return ("[" + Min + ":" + Sec + "." + Mili + "] ");
}

//Select the directory
public void directSelect(File selection) {
  if (selection == null){
    println("Window closed or user hit cancel");
    exit();
  } else {
    println("Selected " + selection.getAbsolutePath());
    selectedDirectory = archive.makeDirectory(selection.getAbsolutePath());
  }
  addMusicFiles(selection);
  folderSelected = true;
}

public void addMusicFiles(File selection){
  ls = listf(selection);
  int x = xInit;
  int y = yInit;
  for(int i = 0; i < ls.size(); i++){
    files.add(new MusicFile(x, y, ls.get(i)));
    y+=38;
  }
}

public static FilenameFilter filter = new FilenameFilter(){
  public boolean accept(File f, String name){
    return name.endsWith(".txt");
  }
};

//Thanks to Cyrille Ka on stackoverflow in 2013
public static List<File> listf(File directoryName) {
  File directory = directoryName;
  
  List<File> resultList = new ArrayList<File>();

  // get all the files from a directory
  File[] fList = directory.listFiles(filter);
  resultList.addAll(Arrays.asList(fList));
  for (File file : fList) {
    if (file.isFile()) {
      //System.out.println(file.getAbsolutePath());
    } else if (file.isDirectory()) {
      resultList.addAll(listf(new File(file.getAbsolutePath())));
    }
  }
  return resultList;
}

//file selection code
public void fileSelected(File selection){
  fileSelected = true;
  if (selection == null){
    println("Invalid filetype/no file selected");
    exit();
  } else {
    println("Selected " + selection.getAbsolutePath());
  }
  String[] lyrrayPart = loadStrings(selection);
  lyrics = new String[lyrrayPart.length+1];
  lyrics[0] = " ";
  arraycopy(lyrrayPart, 0, lyrics, 1, lyrrayPart.length);
  
  lyricsName = selection;
  lryc = new String[lyrics.length+1];
  lyrName = lyricsName.toString();
  fName = lyrName.substring(0, (lyrName.length()-4));
  song = minim.loadFile(fName+".mp3");
  surface.setTitle("Loading...");
  songDummy = new SoundFile(this, fName+".mp3", false);
  println("Song loaded");
  surface.setTitle(selection.getName().substring(0, selection.getName().length()-4));
}

public void mouseClicked(){
  clicked = true;
}

public void selector(){
  int i = 0;
  int foundClick = 0;
  Boolean fc = false;
  for(i = 0; i < files.size(); i++){
    MusicFile mf = files.get(i);
    mf.fileDisplay();
    if(clicked && !menuOpen){
      if(mf.UIfileSelected()){
        foundClick = i;
        fc = true;
      }
    }
  }
  if(fc){
    activeFileIndex = foundClick;
    fileSelected(ls.get(foundClick));
  }
}

//Handle end of song menu
public void EoSMenu(){
  fill(selectionColour);
  textSize(40);
  text("Lyrics Complete!", 20, 220); 
  int xTemp = xInit+40;
  int yTemp = yInit+95;
  String[] eos = {"Save & Select New", "Restart This Song", "Save & Choose New Directory", "Save & Quit", "Quit Without Saving"};
  int i = 0;
  int foundClick = 0;
  Boolean fc = false;
  for(i = 0; i < eos.length; i++){
    ui.menuDisplay(eos[i], xTemp, yTemp);
    if(clicked){
      if(ui.UIoptionSelected(eos[i], xTemp, yTemp)){
        foundClick = i;
        fc = true;
      }
    }
    yTemp += 45;
  }
  clicked = false;
  if(fc){
    songEnd(foundClick);
  }
}

//Handle end of song saving & such
public void songEnd(int a){
  int selection = a;
  LyricSync = Arrays.copyOf(lryc, lryc.length-1);
  ui.lyricDisplay(lyrics, line, xInit, yInit);
  String fileName = fName+".lrc";
  //save and select new + Choose new directory
  if(selection == 0 || selection == 2){
    println("Saved song, selecting new");
    saveStrings(fileName, LyricSync);
    archiveLyrics();
    song.pause();
    fill(textColour);
    resetVars();
    if(selection == 2){
      files = new ArrayList<>();
      selectFolder("Select directory of music:", "directSelect");
      print(", and selecting new directory");
    }
  }
  //Restart this song
  else if(selection == 1){
    println("Restarted song");
    fill(textColour);
    song.rewind();
    song.pause();
    firstTime = true;
    currentMin = 0;
    currentSec = 0;
    currentMili = 0;
    line = 0;
  } 
  //Save & quit
  else if(selection == 3){
    println("Saved & quit");
    saveStrings(fileName, LyricSync);
    archiveLyrics();
    surface.setTitle("Saving...");
    exit();
  }
  //Quit w/o saving
  else if(selection == 4){
    println("Exited without saving");
    surface.setTitle("Quitting Safely...");
    exit();
  }
}

public void archiveLyrics(){
  if(archive.fileTransfer(selectedDirectory, lyricsName.getAbsolutePath()) && doArchive){
    println("Removing txt file from original directory...");
    files.remove(activeFileIndex);
    ls.remove(activeFileIndex);
    lyricsName.delete();
  } else if(doArchive){
    failedToArchive = true;
    archiveFailedTimer = millis();
    println("File not added to archive - not deleting original");
  } else {
    println("doArchive (" + doArchive + ") should be false");
  }
}

//Reset all variables to starting state (bar directory)
public void resetVars(){
  minim = new Minim(this);
  ui = new Controller();
  firstTime = true;
  clicked = false;
  line = 0;
  xInit = 30;
  yInit = 150;
  currentMin = 0;
  currentSec = 0; 
  currentMili = 0;
  lyrics = null;
  lryc = null; 
  LyricSync = null;
  fileSelected = false;
  song = null;
  songDummy.removeFromCache();
  songDummy = null;
  surface.setTitle("Lyrical");
}
public class Archive{
  String archiveName = "Lyrical_Archive";
  public Archive(){  
  }
  
  //Create archive directory if none exists - returns false if created, true if existing
  public File makeDirectory(String path){
    path+="\\" + archiveName;
    File archDir = new File(path);
    Path tempath = Paths.get(path);
    //if the directory already exists
    if(Files.exists(tempath)){
      println("Archive directory already exists!");
      return archDir;
    } else if(archDir.mkdir()) {
      println("Archive directory created");
      return archDir;
    }
    println("Archive doesn't exist, but failed to be created!");
    println("Exiting program...");
    exit();
    return archDir;
  }
  
  public Boolean fileTransfer(File f, String path){
    try{
      File pathFileTemp = new File(path);
      Path archDir = Paths.get(f.getAbsolutePath() + "\\" + pathFileTemp.getName());
      Path textFile = Paths.get(path);
      Files.copy(textFile, archDir, StandardCopyOption.REPLACE_EXISTING);
    
      if(Files.exists(archDir)){
        File orig = textFile.toFile();
        File copi = archDir.toFile();
        String[] original = loadStrings(orig);
        String[] copied = loadStrings(copi);
        if(copied.length == original.length){
          for(int i = 0; i < original.length; i++){
            if(!original[i].equals(copied[i])){
              println("Archival failed, archived file contents not equal to original!");
              return false;
            }
          }
        } else {
          println("Archival failed, archived file different length to original!");
          return false;
        }
      } else {
        println("Archival failed, original file not copied!");
      }  
      println("Successfully copied file!");
      return true;
    } catch (IOException io){
      println("Archival failed");
      return false;
    }
  }
}
public class MusicFile{
  int x, y, tempx;
  int currentMils = 0;
  File song;
  String name, tempName;
  int textScale = 20;
  public MusicFile(int xa, int ya, File music){
    x = xa;
    tempx = x;
    tempName = name;
    y = ya - 75;
    song = music;
    name = song.getName().substring(0, music.getName().length()-4);
  }
  
  public String name(){
    return name;
  }
  
  public void fileDisplay(){
    tempName = name;
    fill(buttonColour);
    if(UIfileSelected() && !menuOpen){
      fill(selectionColour);
      if(textWidth(name) + tempx > .95f*width){
        if(currentMils == 0){
          currentMils = millis();
        }
        tempName += "   ||   ";
        tempx = x - PApplet.parseInt(((millis()-currentMils))%15000/15000.0f * textWidth(name));
        tempName += tempName;
      }
    } else {
      tempx = x;
      currentMils = 0;
    }
    textSize(textScale);
    rect(x-10, y+10, textWidth(name)+10, textScale+10, 0, 10, 10, 0);
    fill(textColour);
    text(name, tempx-5, y+textScale+11);
    fill(backgroundColour);
    rect(0, y+10, x-10, textScale+10);
  }
  
  public boolean UIfileSelected(){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+textScale+10){
      return true;
    }
    return false;
  }
}
public class Options{
  int buttonScale = 20;
  Boolean boo = false;
  int openTime = 0;
  int setHeight = height/3;
  float menuHeight = height/3;
  
  public Options(){ 
  }
  
  public void button(Boolean mouseReleased){
    textSize(buttonScale);
    fill(buttonColour);
    if(boo){
      menuOpen = true;
      stroke(selectionColour);
      fill(buttonColour, 155);
      menuHeight = height - (millis()-openTime)*4;
      if(menuHeight <= setHeight){
        menuHeight = setHeight;
      }
      rect(width/20, menuHeight, width-2*width/20, height*2/3, 20, 20, 20, 20);
      
      doArchive = menuButtons("Archive .txt files on .lrc generation", PApplet.parseInt(width/20+30), PApplet.parseInt(menuHeight+30), mouseReleased, doArchive);
      
      fill(selectionColourSecondary);
      stroke(textColour);
    } else {
      menuOpen = false;
    }
    menuDisplay(">", PApplet.parseInt(width-textWidth(">")-5), height-buttonScale-45, mouseReleased);
  }
  
  //display the options menu button & handle if it's active or not
  public void menuDisplay(String name, int x, int y, Boolean mouseReleased){
    stroke(selectionColourSecondary);
    if(optionSelected(name, x, y)){
      fill(selectionColour);
      if(mouseReleased){
        boo = !boo;
        openTime = millis();
      }
    }
    textSize(buttonScale);
    rect(x-10, y+10, textWidth(name)+13, textWidth(name)+13, 10, 10, 10, 10);
    fill(textColour);
    text(name, x-3, y+buttonScale+9);
    stroke(backgroundColour);
  }
  
  //Handle the options in the menu
  public Boolean menuButtons(String name, int x, int y, Boolean mouseReleased, Boolean valueChange){
    stroke(selectionColourSecondary);
    Boolean testSelected = optionSelected(name, x, y);
    if(testSelected || valueChange){
      fill(selectionColour);
      if(mouseReleased && testSelected){
        return !valueChange;
      }
    }
    textSize(buttonScale);
    rect(x-10, y+10, textWidth(name)+13, buttonScale+10, 10, 10, 10, 10);
    fill(textColour);
    text(name, x-3, y+buttonScale+12);
    stroke(backgroundColour);
    return valueChange;
  }
  
  //returns if mouse is hovering over an element
  public boolean optionSelected(String name, int x, int y){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+buttonScale+10){
      return true;
    }
    return false;
  }
}
public class Controller{
  int textScale = 25;
  Boolean pressing = false;
  AudioMetaData meta;
  public Controller(){
  }
  int xPos;
  public void songInfo(){
    fill(textColour);
    textSize(45);
    String seconds = "Loading...";
    //I have to do it this way because the way that minim handles time metadata is broken
    //and the default processing sound library uses to low a sample rate 
    //attempting to change it results in so many errors - it's a known bug
    if (song != null){
      if(songDummy != null){
        int time = PApplet.parseInt(songDummy.duration());
        if(time%60 > 9){
          seconds = str(time%60);
        } else if(time%60 != 0){
          seconds = "0" + time%60;
        } else {
          seconds = "00";
        }
        seconds = str(time/60) + ":" + seconds;
      }
      
      meta = song.getMetaData();
      String songname = meta.fileName();
      File sn = new File(songname);
      songname = sn.getName();
      songname = "Song: " + songname.substring(0, songname.length()-4);
      textSize(30);
      if(textWidth(songname) > .85f*width){
        songname += "   ||   ";
        xPos = PApplet.parseInt((1000-millis())%20000/20000.0f * textWidth(songname));
        songname += songname;
      } else {
        xPos = 15;
      }
      fill(selectionColour);
      text(songname, xPos, 64);
      textSize(15);
      fill(selectionColourSecondary);
      text("By " + meta.author(), 33, 83);
      textSize(20);

      text("Lines: " + (lyrics.length-1), 15, 35);
      textSize(30);
      text(currentMin + ":" + currentSec, 105, 35);
      textSize(20);
      text("   /" + seconds, 80+2*textWidth(currentMin + ":" + currentSec), 35);
      textSize(25);
      float pos = song.position();
      float len = songDummy.duration()*1000;
      float percent;
      if(pos < len){
        percent = pos*100.0f/len;
      } else {
        percent = 100;
      }
      fill(textColourSecondary);
      text(PApplet.parseInt(percent) + "%", 6*width/28, 115);
      int percentBar = PApplet.parseInt((percent/100.0f) * (3*width/7));
      fill(textColour);
      rect(width/28, 120, 12*width/28, 10, 8);
      fill(selectionColour);
      rect(width/28, 120, percentBar, 10, 8);
    } else if (lyrics == null){
      if(songDummy == null && fileSelected){
        loading();
        println("Loading song...");
      } else if(folderSelected){
        text("Please Select Song", 25, 60);
      } else{
        textSize(40);
        text("Please Select Song Folder", 25, 50);
        textSize(15);
        text("Ensure each song [.mp3] you wish to give lyrics has a matching .txt file \n which share a directory and filename with the song", 20, 90);
        fill(selectionColour);
        text("NOTE: If there is a .lrc for a song already in this directory, saving lyrics that song will overwrite it", 15, 150);
      }
    }
    volumeSlider();
  }
  
  public void lyricDisplay(String[] lyr, int pos, int x, int y){
    textSize(20);
    //keep text in frame
    int a = 0;
    if(pos > 1){
      a = pos-1;
    }
    for(int i = a; i < lyr.length; i++){
      //highlight current lyric
      if(i == pos-1){
        fill(selectionColour);
        //visibility for instrumental sections
        if(!lyr[i].matches(".*[a-zA-Z]+.*")){
          text("/////////////", x+25, y);
        }
      }
      else{
        fill(textColour);
      }
      if(lyrics != null && line == lyrics.length){
        fill(selectionColour);
      }
      //show lyrics
      textSize(20);
      text(lyr[i], x+25, y);
      textSize(13);
      fill(textColourSecondary);
      if(i > 0){
        text(i + "/" + (lyr.length-1), x-20, y);
      }
      y+=23;
    }
  }
  
  public void loading(){
    textSize(40);
    String elli = "";
    for(int i = 0; i < second(); i++){
      elli += ".";
      if(elli.length() > 3){
        elli = "";
      }
    }
    fill(textColour);
    text("Loading Song" + elli, 25, 60);
    println("Loading Song" + elli);
  }
  
  public void menuDisplay(String name, int x, int y){
    fill(buttonColour);
    if(UIoptionSelected(name, x, y)){
      fill(selectionColour);
    }
    textSize(textScale);
    rect(x-10, y+10, textWidth(name)+10, textScale+10, 0, 10, 10, 0);
    fill(textColour);
    text(name, x-5, y+textScale+11);
    fill(backgroundColour);
    rect(0, y+10, x-10, textScale+10);
  }
  
  public boolean UIoptionSelected(String name, int x, int y){
    if(mouseX > x-10 && mouseX < x+textWidth(name) && mouseY > y+10 && mouseY < y+10+textScale+10){
      return true;
    }
    return false;
  }
  
  public void volumeSlider(){
    fill(textColourSecondary);
    int sliderX = PApplet.parseInt(width*5.15f/7);
    float volumeWidth = volume/50.0f * PApplet.parseInt(width/4);
    if((mouseX >= sliderX && mouseX <= sliderX+PApplet.parseInt(width/4)) && ((mouseY < 20 && mouseY > 5 && mousePressed) || (pressing && mousePressed))){
      pressing = true;
      volumeWidth = mouseX - sliderX;
      volume = volumeWidth/1.68f/2;
      textSize(13);
      String percentVolume = str(PApplet.parseInt(volume*20)/10.0f) + "%";
      float perVolX = sliderX + volumeWidth-textWidth(percentVolume)-5;
      float perVolY = 34;
      if(perVolX <= sliderX+5){
        perVolY += sliderX+5 - perVolX;
        if(perVolY >= 40){
          perVolY = 40;
        }
        perVolX = sliderX+5;
      }
      text(percentVolume, perVolX, perVolY);
    } else {
      pressing = false;
      textSize(14);
      fill(selectionColourSecondary);
      String vol = "volume".substring(0, PApplet.parseInt(6 * volume/50.0f + 0.5f));
      String ume = "volume".substring(PApplet.parseInt(6 * volume/50.0f + 0.5f));
      float pos = sliderX + PApplet.parseInt(width/4)/2 + textWidth("volume")/2;
      text(vol, pos - textWidth("volume"), 30);
      fill(textColourSecondary);
      text(ume, pos - textWidth(ume), 30);
    }
    //Volume bar
    fill(textColourSecondary);
    rect(sliderX, 10, PApplet.parseInt(width/4), 7, 4, 4, 4, 4);
    //Volume indicator
    fill(selectionColourSecondary);
    circle(sliderX + volumeWidth, 13, 12);
    //Colour aesthetics
    stroke(selectionColourSecondary);
    fill(selectionColourSecondary);
    rect(sliderX, 10, volumeWidth, 6, 4, 4, 4, 4);
    stroke(backgroundColour);
  }
}


  public void settings() { size(675, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Lyrical" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
